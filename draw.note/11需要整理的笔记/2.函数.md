# 函数
>	函数的作用,可以写一次代码,封装到函数中,然后反复的使用这个函数
>	函数也是一个对象
	- 创建一个函数对象(了解),基本不会使用构造函数创建函数对象
	- var fun = New function(); fun就是一个函数对象
	- 可以把要封装的代码以字符串的形式,传递给函数对象


##  声明函数:
	- 自定义函数:

	```
		function 函数名(形参1,..,形参n){
			函数体;
			return 返回值;
		}
	```
	- 匿名函数

	```
		function(){} //这是一个匿名函数,匿名函数本身就是一个函数对向
		
		//匿名函数要反复使用要定义一个变量,将匿名函数赋值给变量
		var fun = function(){};  //因为是赋值语句所以一般写上;
		fun(); //通过变量名+() 调用
	```


##	函数的参数
+	调用函数时解析器不会检查实参的类型,也不会检查实参的数量,所以多传几个实参不会赋值
	
		
## 函数调用
+ 在js标签内调用 函数名(实参1,...,实参n);//直接调用
+ 在html中调用 在标签内通过事件调用 onclick="函数名(实参1,..,实参n)"


## 函数的返回值
	调用函数之后会获得一个返回值
	在函数中return 之后的代码不会被执行
	return 默认返回值为 undefined
	return 可以返回任意类型的值

	
## 自执行函数(立即执行函数)
+	如果要封装一个代码块,并且自执行一次,需要变量名吗?
	变量名会在cpu中开辟空间,占用资源.

	``` 
		;(function(){		//习惯在前面加分好避免前面代码忘加分号的情况
			console.log("helloworld");
		})();
	```
	
## 隐式全局变量
+	在函数中如果给一个没有声明的变量赋值,全局作用域中也没有声明该变量,
	那么该变量会隐式声明为全局变量,但是这种语法是错误的,在严格模式下会报错.

	```
	function say(){
			// 隐式全局变量
			// 但是这是错误的 在严格模式下 会报错 
			age = 20;
			alert('my age is '+age);
		}
		say();
		alert(age);
	```