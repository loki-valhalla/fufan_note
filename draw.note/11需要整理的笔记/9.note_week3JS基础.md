## 关于运行内存和硬盘内存
+ 电脑在运行程序的时候会把下载在硬盘上的东西加载到运行内存中去(cpu中的内存计算数据快,ps:所以在玩游戏的过程中都会出现loading的过程就是在加载硬盘中的数据到运存).
+ 声明变量的时候就会在运存中开辟一块属于自己的空间.

## github上传到库
+ 进入文件夹,右键选择git bash here
+ git init 创建仓库
+ 输入git status 查看仓库状态
	- 如果存在红色文件,说明文件内容有变动
	- 绿色文件说明文件已经存到暂存区,还未存储的存储区
+ git add . 添加到暂存区
+ 输入 git commit -m'first commit'; 注意:-m不能忘记
+ 建立远程源 git remote add origin https://github.com/nevermo2013/test3.git
+ git push -u origin master
+ 以后的推送 直接add . 然后push


## JS基础
>	        W3C标准有效促进了Web技术的互相兼容,对互联网技术的发展和应用起到了基础性和根本性的作用
>	        网页主要有三部分组成:结构(Structure) 表现(Presentation) 和行为(Behavior)

+ 结构:
	- html
+ 表现:
	- css
+ 行为:
	- DOM:DOM的标准化组织是W3C
	- ECMAScript:ECMAScript是ECMA指定的JAVAScript的标准. 现遵循的是ES6,所学习的是ES5
>	注意:BOM缺乏标准,BOM最初是NetScript浏览器标准的一部分.
>	ECMAScript不是语言是一种标准


+ js的特点:
	- 简单易懂
	- 解析执行
	- 基于对象
	- 面向过程

+ JS书写位置
	- 内嵌式
		- JS的内部样式可以写在html的各个位置但一般写在head下方或者body的下方
		- 页面显示初始化的js必须放在head里面,因为初始化都要求提前进行(如给页面body设置css等);
		- 而如果是通过事件调用执行的function那么对位置没什么要求(一般会放在body下方)
	- 外链式
		`<Script src="">`
	- 一行的结束通常在结尾加上一个分号";"来表示语句的结束,分号可以不写,但我们要养成良好的编程习惯.
## 变量
>	从编程角度讲,变量是用来存储数据的容器
- 变量名命名要遵循命名规则:
>	1.变量必须使用字母,下划线_ $符开始
>	2.使用任意多个英文字母 数字 下划线 美元符组成,也可以使用汉字但不推荐
>	3.不能使用javaScript关键词和javaScript保留字
>	4.区分大小写
>		注意:变量虽然可以不声明直接使用,但不规范

## 全局作用域
+ 直接编写的在js标签中的代码,都在全局作用域
+ 全局作用于在页面打开时创建,页面关闭时销毁
+ 全局作用域中,有一个全局对象window可以直接使用(它代表的是一个浏览器的窗口)
	- 声明的变量和函数都作为window的属性和方法存在
+ 全局作用于中的变量都是全局变量,在页面的任意位置都可以访问到


## 函数作用域(局部作用域)
+	函数作用域调用函数时创建函数作用域,函数执行完毕以后,函数作用域销毁.
+	每调用一次函数就会创建一个函数作用域,即使是调用相同的函数,它们也是创建各自的函数作用域.
+	函数作用域可以访问到全局变量,但是全局作用域访问不到函数作用域中的变量,
+	当在函数作用域中操作一个变量时,会现在自身作用域中寻找有就直接使用,没有就向上一级(不一定是全局)作用域中寻找
	- 在函数作用域中要想访问同名的全局变量可以通过window.变量名 访问
+	在函数作用域中如果不使用var声明的变量就会使用全局的,修改值就是修改了全局中的值(使用的就是全局中的那一个)
+	定义形参就相当于在函数作用域中声明了变量:因此调用了有形参的函数但是没有传值,就报undefined	
	
	
## 变量的声明提前
+ 使用var关键字声明的变量,会在所有代码执行之前被声明(但是不会被赋值,等到执行到赋值的那一行时才会被赋值)
	-函数作用域中的变量声明提前,会在调用函数的时,代码执行之前被声明. 函数作用域中的函数声明也和全局中的函数声明一样(函数作用域就相当于一个小的全局,特点基本相同,除了范围大小不同,生命周期不同)
+ 但是如果不用var关键字声明,则不会被声明提前
- 例:先使用变量后声明,那么会变成undefined

```
	console.log(age);
	var age =30;
	||会变成以下形式
	var age;
	console.log(age);
	age=30;
```
## 函数的声明提前
+	使用函数声明形式创建的function 函数名(){}
+	会在所有的代码执行之前就被创建
+	使用函数表达式创建的函数,不会被声明提前,所以不能再声明之前调用,var 函数名 = function(){};
	- 如果提前调用 函数名() 会报错,但是变量名 函数名 是被提前的 


## JS的输出
- document.wirte("<br>");会输出一个br标签的效果,而不是内容<br>
	输出多项内容用+号连接

- 警告(alert消息对话框)
	alert于decument.write相似
	消息对话框可以用于调试
	
	
- 控制台输出: console.log(); 一般用于调试,ie8不支持console这个方法

- 确认confirm消息对话框:
	confirm("弹出的内容");
	确定就会返回true 否则就会返回false;

- 提问prompt消息对话框:
	prompt("输入你的成绩"),提示下面会有一个输入框,返回值是你输入的内容

- 打开新窗口window.open('url','窗口名称'(打开位置_self,_blank...),'参数');

- 关闭窗口
	window.close()关闭窗口
	窗口对象.close()需要创建窗口对象 var 

## 运算符
>	运算符可以把字符串类型的number隐式转换成number类型进行比较(不建议)

+ 比较运算符
	`> < >= <= == !=` 结果为boolean类型
	
>	==(不比较数据类型)和 ===(先比较数据类型) 
+ 算术运算符
	`+ - * / %`
>	'+'可以用作字符串拼接,因此＋号不会进行number类型和字符串类型的数值相加(也就是不会进行字符串隐式转换)
>	当一个number类型-非数值的字符串时,结果为NaN(NOT A NUMBER);且NaN==NaN 结果为false	
>	当0做除数时,结果等于Infinity(无限大)
>	没有声明变量,结果为变量名+is a not difined)
+ 带操作的算术运算符
	`+=  -= *= /= ++ --`
	`i++和++i //++在后是后运算,在前是先运算`

+ 逻辑运算符
	|| //逻辑或
	&& //逻辑与
>		操作符之间的优先级:算术运算符>比较运算符>逻辑运算符>"=(赋值)";

## 基本数据类型
>	JS中的基本数据类型有六种:
>	js中的类型是小写开头
+ 1.number:小数 整数(包括负数),由于不区分double型和int型所以不会有java中的一些运算问题
+ 2.string:字符串类型(单引号或双引号都可以)
	转义字符:\n 换行    \' 表示'    \" 表示"    \t 制表符    \\ 表示\
+ 3.boolean:布尔类型  true|false
+ 4.undefined 未定义 变量只声明没有初始化
	- 在变量提升（预解析）阶段，只声明未定义，默认值就是undefined。
	- 函数定义没有返回值（return或者return后面什么也不带），默认的返回值就是undefined。
	- 函数定义形参不传值，默认就是undefined。
	- 对象没有这个属性名，属性值默认就是undefined。
	- 在数组的find方法中，没有找到的情况下是undefined。
	- 在JS的严格模式下（”use strict”），没有明确的主体，this指的就是undefined。

+ 5.null 
+ null类型的值只有一个null,null专门用来表示为空对象使用typeof检查null 会返回object

+ object 属于引用数据类型
	- 
>	如何判断null
	```
		//判断null
		var exp =null;
		alert(typeof exp)//为了向下兼容 typeof 判断空 值会返回object
		//因此我们一般使用alert(!exp) 判断null
	```
- typeof可以判断基本数据类型
- 强制转换成string  a.tostring() 返回值是一个string类型的a  null和undefined没有toString()方法
- String(a) 强制类型转换; 可以把null 和undefined转换成string
	- number 和 boolean的强制类型转换底层也是调用toString()方法,null和undefined不是
- Number(a)
	- 字符串转数字的字符串,则直接转为number
	- 如果是非数字字符串,则是NaN
	- 如果是空串或者是空格则是0
	- 布尔 中true是1 false是0  null是0 undefined是NaN
- parseInt()| parseFloat() 专门对付字符串 会将字符串中的数字取出来转换成number


# 内置对象:
## Math 对象:
	工具类,封装了数学运算相关的静态方法和属性
	比如:Math.PI 表示π

+ 1.Math.ceil() 向上取整 负值往大了取
+ 2.Math.floor() 向下取整 负值往小了取
+ 3.Math.max(...) 求n个数中的最大值
+ 4.Math.min() 求n个数中的最小值
+ 5.Math.random() 随机数 [0,1) 
	- 生成[x,y)区间的随机数 Math.floor(Math.random()*(y-x)+x)
+ 6.Math.pow(x,y) x的y次方 
+ 	Math.sqrt(x) 对x进行开方运算
+ 7.Math.round(x) 四舍(负值往小了舍)五入(往大了入),小数位多了会有偏差 不推荐使用
+ 8.Math.abs(x) 返回绝对值
+ 
## Date 对象:
+ Date 日期对象 用于获取年月日时分秒
	var date = new Date(); 输出date是一串时间 (中国标准时间)
	- 创建一个指定的时间 对象 事件的格式为字符串的日/月/年 时:分:秒
	- 例:2019/1/22 new Date("1/1/2019")
	-    2019/1/22 12:01:55 new Date("1/1/2019 12:1:55");
+ date.getFullYear();获取年
+ date.getMonth();获取月0~11月
+ date.getDate();获取日
+ date.getHours();获取小时
+ date.getMinutes();获取分
+ date.getSeconds();获取秒
+ date.getDay();获取周几(0-6) 0表示周日
+ date.getYear(); 这个属性在2000之前都是以后两位表示,例如1999年 表示为99 因此2000以后就是在基础上进1 ,以三位表现例如2019表现为119 	
+ date.getTime();时间戳(从格林威治标准时间(北京时间和格林威治标准时间有8个小时的时差)1970年1月1日0时0分0秒到当前日期所花费的毫秒数毫秒)
+ Date.now() 当前时刻的时间戳
 - 可以利用时间戳测试代码的性能
 	```
	var start = Date.now();
	 代码块
	var end = Date.now();
	console.log("执行了"+end-start+"毫秒");
	```
 - 计算机底层在保存时间时,使用的是时间戳
- 闰秒不会影响                                                                                                                      